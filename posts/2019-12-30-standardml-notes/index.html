<!doctype html><html lang=en-us><head><link rel=preload href=/lib/font-awesome/webfonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/font-awesome/webfonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/font-awesome/webfonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><script type=text/javascript src=https://latest.cactus.chat/cactus.js></script>
<link rel=stylesheet href=https://latest.cactus.chat/style.css type=text/css><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Standard ML notes | almo7aya.md</title><link rel=canonical href=/posts/2019-12-30-standardml-notes/><meta name=description content="Senior web engineer supercharged with typescript, rust, swift, and lua, with hands on experience on various technologies, love to create and contribute to the open source community, working @ [anghami](https://anghami.com)."><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="Standard ML notes"><meta property="og:description" content="Basics Comments (* SML comment *) Variable bindings and Expressions val x = 34; (* static environment: x : int *) (* dynamic environment: x --> 34 *) val y = x + 1; (* Use tilde character instead of minus to reprsent negation *) val z = ~1; (* Integer Division *) val w = y div x Strings:"><meta property="og:type" content="article"><meta property="og:url" content="/posts/2019-12-30-standardml-notes/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-12-30T09:00:00+00:00"><meta property="article:modified_time" content="2019-12-30T09:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Standard ML notes"><meta name=twitter:description content="Basics Comments (* SML comment *) Variable bindings and Expressions val x = 34; (* static environment: x : int *) (* dynamic environment: x --> 34 *) val y = x + 1; (* Use tilde character instead of minus to reprsent negation *) val z = ~1; (* Integer Division *) val w = y div x Strings:"><link rel=stylesheet href=/css/styles.e5167195519abfaf274ddb07329311b636a8257fea33185bad548dd24d0465a9a7e29548449a68c57483ddc2e52a149b1dcc233a7ee992acdeebd350673ad6e6.css integrity="sha512-5RZxlVGav68nTdsHMpMRtjaoJX/qMxhbrVSN0k0EZamn4pVIRJpoxXSD3cLlKhSbHcwjOn7pkqze69NQZzrW5g=="><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script>
<script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=icon type=image/png href=/images/favicon.ico><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-KLG0T39J77","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body class=ltr><div class="max-width mx-auto content index pt4 px3"><header id=header><a href=/><div id=title><h1>&nbsp;almo7aya.md&nbsp;</h1><span class=repeated></span></div></a></header><article class=post itemscope itemtype=http://schema.org/BlogPosting><header><h1 class=posttitle itemprop="name headline">Standard ML notes</h1><div class=meta><div class=postdate><time datetime="2019-12-30 09:00:00 +0000 UTC" itemprop=datePublished>2019-12-30</time> &nbsp;</div>&nbsp;<div class=article-read-time><i class="far fa-clock"></i>
13 minute read</div></div></header><div class=content itemprop=articleBody><h2 id=basics>Basics</h2><h3 id=comments>Comments</h3><pre tabindex=0><code class=language-ML data-lang=ML>(* SML comment *)
</code></pre><h3 id=variable-bindings-and-expressions>Variable bindings and Expressions</h3><pre tabindex=0><code class=language-ML data-lang=ML>val x = 34;
(* static environment: x : int *)
(* dynamic environment: x --&gt; 34 *)
val y = x + 1;

(* Use tilde character instead of minus to reprsent negation *)
val z = ~1;

(* Integer Division *)
val w = y div x
</code></pre><p>Strings:</p><pre tabindex=0><code class=language-ML data-lang=ML>(* `\n`„ÅÆ„Çà„ÅÜ„Å™„Ç®„Çπ„Ç±„Éº„Éó„Ç∑„Éº„Ç±„É≥„Çπ„ÅåÂà©Áî®„Åß„Åç„Çã *)
val x = &#34;hello\n&#34;; 
(* ÊñáÂ≠óÂàó„ÅÆÈÄ£Áµê„Å´„ÅØ&#39;^&#39;„Çí‰Ωø„ÅÜ *)
val y = &#34;hello &#34; ^ &#34;world&#34;;
</code></pre><p>An ML program is a sequence of bindings. Each binding gets <strong>type-checked</strong> and then <strong>evaluated</strong>.
What type a binding has depends on a static environment. How a binding is evaluated depends on a dynamic environment.
Sometimes we use just <code>environment</code> to mean dynamic environment and use <code>context</code> as a synonym for static environment.</p><ul><li>Syntaxs : How to write it.</li><li>Semantics: How it type-checks and evaluates</li><li>Value: an expression that has no more computation to do</li></ul><h3 id=shadowing>Shadowing</h3><p><strong>Bindings are immutable</strong> in SML. Given <code>val x = 8 + 9;</code> we produce a dynamic environment where x maps to 17.
In this environment x will always map to 17; there is no &ldquo;assignment statement&rdquo; in ML for changing what x maps to.
You can have another binding later, say <code>val x = 19;</code>, but that just creates a differnt environment
where the later binding for x <strong>shadows</strong> the earlier one.</p><h3 id=function-bindings>Function Bindings</h3><pre tabindex=0><code class=language-ML data-lang=ML>fun pow (x:int, y:int) = (* correct only for y &gt;= 0 *)
    if y = 0
    then 1
    else x * pow(x, y-1);

fun cube (x : int) = 
    pow(x, 3);

val ans = cube(4);
(* The parentheses are not necessary if there is only one argument
     val ans = cube 4; *)
</code></pre><ul><li>Syntax: <code>fun x0 (x1 : t1, ..., xn : tn) = e</code></li><li>Type-checking:<ul><li><code>t1 * ... * tn -> t</code></li><li>The type of a function is &ldquo;argument types&rdquo; -> &ldquo;reslut types&rdquo;</li></ul></li><li>Evaluation:<ul><li>A function is a value</li><li>The environment we extends arguments with is that ‚Äúwas current‚Äù when the function was defined, not the one where it is being called.</li></ul></li></ul><h3 id=pairs-and-other-tuples>Pairs and other Tuples</h3><pre tabindex=0><code class=language-ML data-lang=ML>fun swap (pr : int*bool) =
    (#2 pr, #1 pr);

fun sum_two_pairs (pr1 : int * int, pr2 : int * int) =
    (#1 pr1) + (#2 pr1 ) + (#1 pr2) + (#2 pr2);

fun div_mod (x : int, y: int) =
    (x div y, x mod y);

fun sort_pair(pr : int * int) =
    
    if (#1 pr) &lt; (#2 pr) then
	pr
    else
	(#2 pr, #1 pr);
</code></pre><p>ML supportstuplesby allowing any number of parts. Pairs and tuples can be nested however you want. For example, a 3-tuple (i.e., a triple) of integers has type int<em>int</em>int. An example is (7,9,11) and you retrieve the parts with #1 e, #2 e, and #3 e where e is an expression that evaluates to a triple.</p><pre tabindex=0><code class=language-ML data-lang=ML>val a = (7, 9, 11) (* int * int * int *)
val x = (3, (4, (5,6))); (* int * (int * (int * int)) *)
val y = (#2 x, (#1 x, #2 (#2 x))); (* (int * (int * int)) * (int * (int * int)) *)
val ans = (#2 y, 4); (* (int * (int * int)) * int *)
</code></pre><h3 id=lists>Lists</h3><pre tabindex=0><code class=language-ML data-lang=ML>val x = [7,8,9];
5::x; (* 5 consed onto x *)
6::5::x;
[6]::[[1,2],[3,4];
</code></pre><p>To append a list t a list, use list-append operator <code>@</code>:
<a href=%5Bhttp://sml-family.org/Basis/list.html%5D(http://sml-family.org/Basis/list.html)>ReferenceÔºö# The Standard ML Basis Library</a></p><blockquote><p>Interface:
<strong>val</strong> <a href=http://sml-family.org/Basis/list.html#SIG:LIST.@:VAL>@</a> <strong>:</strong> <em>&lsquo;a</em> list * <em>&lsquo;a</em> list <strong>-></strong> <em>&lsquo;a</em> list</p></blockquote><pre tabindex=0><code>val x = [1,2] @ [3,4,5]; (* [1,2,3,4,5] *)
</code></pre><p>Accessing:</p><pre tabindex=0><code class=language-ML data-lang=ML>val x = [7,8,9];
null x; (* False *)
null []; (* True *)
hd x; (* 7 *)
tl x; (* [8, 9] *)
</code></pre><h3 id=list-functions>List Functions</h3><pre tabindex=0><code class=language-ML data-lang=ML>fun sum_list(xs : int list) =
    if null xs
    then 0
    else hd xs + sum_list(tl xs);

fun list_product(xs : int list) =
    if null xs
    then 1
    else hd xs * list_product(tl xs);

fun countdown(x : int) =
    if x = 0
    then []
    else x :: countdown(x - 1);

fun append (xs : int lisst, ys : int list) =
    if null xs
    then ys
    else (hd xs) :: append((tl xs), ys);

fun sum_pair_list(xs : (int * int) list) =
    if null xs
    then 0
    else #1 (hd xs) + #2 (hd xs) + sum_pair_list(tl xs);

fun firsts (xs : (int * int) list) =
    if null xs
    then []
    else (#1 (hd xs)) :: firsts(tl xs);

fun seconds (xs : (int * int) list) =
    if null xs
    then []
    else (#2 (hd xs)) :: seconds(tl xs);

fun sum_pair_list2 (xs : (int * int) list) =
    (sum_list(firsts xs)) + (sum_list(seconds xs));
</code></pre><p>Functions that make and us lists are almost always recursice becasue a list has an unknown length. To write a recursive function the thought process involves two steps:</p><ul><li>think about the <em>base case</em></li><li>think about the <em>recursive case</em></li></ul><h3 id=let-expressions>Let Expressions</h3><ul><li>Syntax: <code>let b1 b2 ... bn in e end</code><ul><li>Each <code>bi</code> is any binding an <code>e</code> is any expression</li></ul></li></ul><pre tabindex=0><code class=language-ML data-lang=ML>let val x = 1
in
    (let val x = 2 in x+1 end) + (let val y = x+2 in y+1 end)
end

fun countup_from1 (x:int) =
    let fun count (from:int) =
        if from=x
        then x::[]
        else from :: count(from+1)
    in
        count(1)
    end
</code></pre><h3 id=options>Options</h3><p>An option value has either 0 or 1 thing: <code>None</code> is an option value carrying nothing whereas <code>SOME e</code> evaluates e to a value v and becomes the option carrying the one value v. The type of <code>NONE</code> is <code>'a option</code> and the type of <code>SOME e</code> is <code>t option</code> if e has type t.</p><p>We have:</p><ul><li><code>isSome</code> which evaluates to false if its argument is NONE</li><li><code>valOf</code> to get the value carried by <code>SOME</code>(raising exception for <code>NONE</code>)</li></ul><pre tabindex=0><code class=language-ML data-lang=ML>fun max1( xs : int list) =
    if null xs
    then NONE
    else
	let val tl_ans = max1(tl xs)
	in
	    if isSome tl_ans andalso valOf tl_ans &gt; hd xs
	    then tl_ans
	    else SOME (hd xs)
	end;
</code></pre><h2 id=some-more-expressions>Some More Expressions</h2><p>Boolean operations:</p><ul><li><code>e1 andalso e2</code><ul><li>if result of e1 is false then false else result of e2</li></ul></li><li><code>e1 orelse e2</code></li><li><code>not e1</code></li></ul><p><strong>‚ÄªSyntax <code>&&</code> and <code>||</code> don&rsquo;t exist in ML and <code>!</code> means something different.</strong></p><p><strong>‚Äª<code>andalso</code> and <code>orelse</code> are just keywords. <code>not</code> is a pre-defined function.</strong></p><p>Comparisons:</p><ul><li><code>=</code> <code>&lt;></code> <code>></code> <code>&lt;</code> <code>>=</code> <code>&lt;=</code><ul><li><code>=</code> and <code>&lt;></code> can be used with any &ldquo;equality type&rdquo; but not with real</li></ul></li></ul><h2 id=build-new-types>Build New Types</h2><p>To Create a compound type, there are really only three essential building blocks:</p><ul><li><strong>Each-of</strong> : A compound type t describes values that contain each of values of type <code>t1</code> <code>t2</code> &mldr; <code>tn</code></li><li><strong>One-of</strong>: A compound type t describes values that contain a value of one of the types <code>t1</code> <code>t2</code> &mldr; <code>tn</code></li><li><strong>Self-refenence</strong>: A compound type t may refer to itself in its definition in order to describe recursive data structures like lists and trees.</li></ul><h3 id=records>Records</h3><p>Record types are &ldquo;each-of&rdquo; types where each component is a named field. The order of fields never matters.</p><pre tabindex=0><code class=language-ML data-lang=ML>val x = {bar = (1+2,true andalso true), foo = 3+4, baz = (false,9) }
#bar x (* (3, true) *)
</code></pre><p>Tupels are actually syntactic sugar for records. <code>#1 e</code>, <code>#2 e</code>, etc. mean: get the contents of the field named 1, 2, etc.</p><pre tabindex=0><code class=language-ML data-lang=ML>- val x = {1=&#34;a&#34;,2=&#34;b&#34;};
val x = (&#34;a&#34;,&#34;b&#34;) : string * string
- val y = {1=&#34;a&#34;, 3=&#34;b&#34;};
val y = {1=&#34;a&#34;,3=&#34;b&#34;} : {1:string, 3:string}
</code></pre><h3 id=datatype-bindings>Datatype bindings</h3><pre tabindex=0><code class=language-ML data-lang=ML>datatype mytype = TwoInts of int*int
		                       | Str of string
                               | Pizza;
val a = Str &#34;hi&#34;; (* Str &#34;hi&#34; : mytype *)
val b = Str; (* fn : string -&gt; mytype *)
val c = Pizza; (* Pizza : mytype *)
val d = TwoInts(1+2, 3+4); (* TwoInts (3,7) : mytype *)
val e = a; (* Str &#34;hi&#34; : mytype *)
</code></pre><p>The example above adds four things to the environment:</p><ul><li>A new type mytype that we can now use just like any other types</li><li>Three constructors <code>TwoInts</code>, <code>Str</code>, <code>Pizza</code></li></ul><p>We can also create a type synonmy which is entirely interchangeable with the existing type.</p><pre tabindex=0><code class=language-ML data-lang=ML>type foo = int
(* we can write foo wherever we write int and vice-versa *)
</code></pre><h2 id=case-expressions>Case Expressions</h2><p>To access to datatype values, we can use a case expression:</p><pre tabindex=0><code class=language-ML data-lang=ML>fun f (x : mytype) =
    case x of
	    Pizza =&gt; 3
      | Str s =&gt; 8
      | TwoInts(i1, i2) =&gt; i1 + i2;

f(Str(&#34;a&#34;)); (* val it = 8 : int *)
</code></pre><p>We separate the branches with the <code>|</code> character. Each branch has the form <code>p => e</code> where p is a pattern and e is an expression. Patterns are used to match against the result of evaluating the case&rsquo;s first expression. This is why evaluating a case-expression is called pattern-matching.</p><h2 id=lists-and-options-are-datatypes-too>Lists and Options are Datatypes too</h2><p><code>SOME</code> and <code>NONE</code> are actually constructors. So you can use them in a case like:</p><pre tabindex=0><code class=language-ML data-lang=ML>fun inc_or_zero intoption =
    case intoption of
	    NONE =&gt; 0
      | SOME i =&gt; i+1;
</code></pre><p>As for list, <code>[]</code> and <code>::</code> are also constructors. <code>::</code> is a little unusual because it is an infix operator so when in patterns:</p><pre tabindex=0><code class=language-ML data-lang=ML>fun sum_list xs =
    case xs of
	    [] =&gt; 0
      | x::xs&#39; =&gt; x + sum_list xs&#39;;

fun append(xs, ys) =
    case xs of
	    [] =&gt; ys
      | x::xs&#39; =&gt; x :: append(xs&#39;, ys);
</code></pre><h2 id=pattern-matching>Pattern-matching</h2><p>Val-bindings are actually using pattern-matching.</p><pre tabindex=0><code class=language-ML data-lang=ML>val (x, y, z) = (1,2,3);
(*
    val x = 1 : int
    val y = 2 : int
    val z = 3 : int
*)
</code></pre><p>When defining a function, we can also use pattern-matching</p><pre tabindex=0><code class=language-ML data-lang=ML>fun sum_triple (x, y, z) =
    x + y + z;
</code></pre><p>Actually, all functions in ML takes one tripple as an argument. There is no such thing as a mutli-argument function or zero-argument function in ML.
The binding <code>fun () = e</code> is using the unit-pattern <code>()</code> to match against calls that pass the unit value <code>()</code>, which is the only value fo a pre-defined datatype <code>unit</code>.</p><p>The definition of patterns is recursive. We can use nested patterns instead of nested cae expressions.</p><p>We can use wildcard pattern <code>_</code> in patterns.</p><pre tabindex=0><code class=language-ML data-lang=ML>fun len xs =
    case xs of
	[] =&gt; 0
      | _::xs&#39; =&gt; 1 + len xs&#39;;
</code></pre><h3 id=function-patterns>Function Patterns</h3><p>In a function binding, we can use a syntactic sugar instead of using case expressions:</p><pre tabindex=0><code class=language-ML data-lang=ML>fun f p1 = e1
  | f p2 = e2
  ...
  | f pn = en
</code></pre><p>for example</p><pre tabindex=0><code class=language-ML data-lang=ML>fun append ([], ys) = ys
  | append (x::xs&#39;, ys) = x :: append(xs&#39;, ys);
</code></pre><h2 id=exceptions>Exceptions</h2><p>To create new kinds of exceptions we can use exception bindings.</p><pre tabindex=0><code class=language-ML data-lang=ML>exception MyUndesirableCondition;
exception MyOtherException of int * int;
</code></pre><p>Use <code>raise</code> to raise exceptions. Use <code>handle</code> to catch exceptions.</p><pre tabindex=0><code class=language-ML data-lang=ML>fun hd xs =
    case xs of
	[] =&gt; raise List.Empty
      | x::_ =&gt; x;

(* The type of maxlist will be int list * exn -&gt; int *)
fun maxlist(xs, ex) =
    case xs of
	[] =&gt; raise ex
      | x::[] =&gt; x
      | x::xs&#39; =&gt; Int.max(x, maxlist(xs&#39;, ex));

(* e1 handle ex =&gt; e2 *)
val y = maxlist([], MyUndesirableCondition)
	handle MyUndesirableCondition =&gt; 42;
</code></pre><h2 id=tail-recursion>Tail Recursion</h2><p>There is a situation in a recursive call called <strong>tail call</strong>:</p><blockquote><p>when f makes a recursive call to f, there is nothing more for the caller to do after the callee returns except return the callee&rsquo;s result.</p></blockquote><p>Consider a sum function:</p><pre tabindex=0><code class=language-ML data-lang=ML>fun sum1 xs =
    case xs of
        [] =&gt; 0
      | i::xs&#39; =&gt; i + sum1 xs&#39;
</code></pre><p>When the function runs, it will keep a call-stack for each recursive call . But if we change a little bit using tail call :</p><pre tabindex=0><code class=language-ML data-lang=ML>fun sum2 xs =
    let fun f (xs,acc) =
        case xs of
            [] =&gt; acc
          | i::xs&#39; =&gt; f(xs&#39;,i+acc)
    in
        f(xs,0)
    end
</code></pre><p>we use a local helper <code>f</code> and a accumulator <code>acc</code> so that the return value of <code>f</code> is just the return value of <code>sum2</code> . As a result, there is no need to keep every call in stack, just the current <code>f</code> is enough. And that&rsquo;s ML and most of other functional programming languages do.
Another example: when reversing a list:</p><pre tabindex=0><code class=language-ML data-lang=ML>fun rev1 lst =
    case lst of
        [] =&gt; []
      | x::xs =&gt; (rev1 xs) @ [x]

fun rev2 lst =
    let fun aux(lst,acc) =
	    case lst of
		[] =&gt; acc
	      | x::xs =&gt; aux(xs, x::acc)
    in
	aux(lst,[])
    end
</code></pre><p><code>rev1</code> is <code>O(n^2)</code> but rev2 is almost as simple as <code>O(n)</code>.</p><p>To make sure which calls are tail calls, we can use a recursive defination of <strong>tail position</strong> like:</p><ul><li>In <code>fun f(x) = e</code>, <code>e</code> is in tail position.</li><li>If an expression is not in tail position, then none of its subexpressions are</li><li>If <code>if e1 then e2 else e3</code> is in tail position, then <code>e2</code> and <code>e3</code> are in tail position (but not <code>e1</code>). (Case-expressions are similar.)</li><li>If <code>let b1 ... bn in e end</code> is in tail position, then e is in tail position (but no expressions in the bindings are).</li><li>Function-call arguments are not in tail position.</li></ul><h2 id=first-class-functions>First-class Functions</h2><p>The most common use of first class functions is passing them as arguments to other functions.</p><pre tabindex=0><code class=language-ML data-lang=ML>fun n_times (f, n, x) =
    if n=0
    then x
    else f (n_times(f, n-1,x))
</code></pre><p>The function <code>n_times</code> is called higher-order funciton. Its type is:</p><pre tabindex=0><code class=language-ML data-lang=ML>fn : (&#39;a -&gt; &#39;a) * int * &#39;a -&gt; &#39;a
</code></pre><p><code>'a</code> means they can be any type. This is called <em>parametric polymorphism</em> , or <em>generic types</em> .</p><p>Instead, consider a function that is not polymorphic:</p><pre tabindex=0><code class=language-ML data-lang=ML>(* (int -&gt; int) * int -&gt; int *)
fun times_until_zero (f, x) =
    if x = 0
    then 0
    else 1 + times_until_zero(f, f x)
</code></pre><h3 id=anonymous-functions>Anonymous Functions</h3><pre tabindex=0><code class=language-ML data-lang=ML>fun triple_n_times (n, x) =
    n_times((fn x =&gt; 3*x), n, x)
</code></pre><p>Maps:</p><pre tabindex=0><code class=language-ML data-lang=ML>(* (&#39;a -&gt; &#39;b) * &#39;a list -&gt; &#39;b list *)
fun map (f, xs) =
    case xs of
	[] =&gt; []
      | x::xs&#39; =&gt; (f x)::(map(f, xs&#39;));
</code></pre><p>Filters:</p><pre tabindex=0><code class=language-ML data-lang=ML>(* (&#39;a -&gt; bool) * &#39;a list -&gt; &#39;a list *)
fun filter (f, xs) =
    case xs of
	[] =&gt; []
      | x::xs&#39; =&gt; if f x
		  then x::(filter (f, xs&#39;))
		  else filter (f, xs&#39;);
</code></pre><h3 id=lexical-scope-vs-dynamic-scope>Lexical scope VS dynamic scope</h3><h3 id=combining-functions>Combining Functions</h3><pre tabindex=0><code class=language-ML data-lang=ML> fun sqrt_of_abs i = (Math.sqrt o Real.fromInt o abs) i;
</code></pre><p>Use our own infix operator to define a left-to-right syntax.</p><pre tabindex=0><code class=language-ML data-lang=ML>infix |&gt;
fun x |&gt; f = f x;
fun sqrt_of_abs i = i |&gt; abs |&gt; Real.fromInt |&gt; Math.sqrt;
</code></pre><h3 id=currying>Currying</h3><pre tabindex=0><code class=language-ML data-lang=ML>(* fun sorted(x, y z) = z &gt;= y andalso y &gt;= x *)
val sorted = fn x =&gt; fn y =&gt; fn z =&gt; z &gt;= y andalso y &gt;= x;

(* just syntactic sugar for code above *)
fun sorted_nicer x y z = z &gt;= y andalso y &gt;= x;
</code></pre><p>when calling curried the function:</p><pre tabindex=0><code class=language-ML data-lang=ML>(* ((sorted_nicer x) y) z *)
(* or just: *)
sorted_nicer x y z
</code></pre><pre tabindex=0><code class=language-ML data-lang=ML></code></pre><h2 id=type-inference>Type Inference</h2><p>Key steps in ML:</p><ul><li>Determine types of bindings in order</li><li>For each val of fun binding:<ul><li>Analyze definition for all necessary facts</li><li>Type erro if no way for all facts to hold</li></ul></li><li>Use type variables like <code>'a</code> for any unconstrained type</li><li>Enforce the value restriction</li></ul><p>One example:</p><pre tabindex=0><code class=language-ML data-lang=ML>(*
	compose : T1 * T2 -&gt; T3
	f : T1
	g : T2
	x : T4
	body being a function has type T3=T4-&gt;T5
	from g being passed x, T2=T4-&gt;T6 for some T6
	from f being passed the result of g, T1=T6-&gt;T7
	from call to f being body of anonymous function, T7 = T5
	all together, (T6-&gt;T5) * (T4-&gt;T6) -&gt; (T4-&gt;T5)
	so (&#39;a-&gt;&#39;b) * (&#39;c-&gt;&#39;a) -&gt; (&#39;c-&gt;&#39;b) 
*)
fun compose (f, g) = fn x =&gt; f (g x)
</code></pre><h3 id=value-restriction>Value restriction</h3><p>A variable-binding can have a polymorphic type only if the expression is a variable or value:</p><pre tabindex=0><code class=language-ML data-lang=ML>val r = ref NONE
val _ = r := SOME &#34;hi&#34;
val i - 1 + valOf (!r)
</code></pre><p>If there is is no value-restriction, the code above will type check, which shouldn&rsquo;t.
With value restriction, ML will give a warning when type-checking:</p><pre tabindex=0><code>- val r = ref NONE;
stdIn:2.5-2.17 Warning: type vars not generalized because of
   value restriction are instantiated to dummy types (X1,X2,...)
val r = ref NONE : ?.X1 option ref
</code></pre><h2 id=mutual-recursion>Mutual Recursion</h2><p>Mutual recursion allows <code>f</code> to call <code>g</code> and <code>g</code> to call <code>f</code>.
In ML, There is an <code>and</code> keyword to allow that:</p><pre tabindex=0><code class=language-ML data-lang=ML>fun p1 = e1
and p2 = e2
and p3 = p3
</code></pre><h2 id=modules>Modules</h2><pre tabindex=0><code class=language-ML data-lang=ML>structure MyMathLib =
struct
fun fact x = x
val half_pi = Math.pi / 2.0
fun doubler x = x * 2
end
</code></pre><h3 id=signatures>Signatures</h3><p>A signature is a type for a module.</p><pre tabindex=0><code class=language-ML data-lang=ML>signature SIGNAME  =
sig types-for-bindings
end
</code></pre><p>Ascribing a signature to a module:</p><pre tabindex=0><code class=language-ML data-lang=ML>structure myModule :&gt; SIGNAME =
struct bindings end;
</code></pre><p>Anything not in the signature cannot be used outside the module.</p><pre tabindex=0><code class=language-ML data-lang=ML>signature MATHLIB =
sig
    val fact : int -&gt; int
    val half_pi : real
    (* make doubler unaccessable outside the MyMathLib *)
    (* val doubler : int -&gt; int *)
end

structure MyMathLib :&gt; MATHLIB =
struct
fun fact x = x
val half_pi = Math.pi / 2.0
fun doubler x = x * 2
end 
</code></pre><h3 id=signature-matching>Signature matching</h3><h2 id=equivalence>Equivalence</h2><ul><li>PL Equivalence</li><li>Asymptotic equivalence</li><li>System equivalence</li></ul></div></article><div class=blog-post-comments><div id=disquss_thread><script src=https://utteranc.es/client.js repo=almo7aya/almo7aya.github.io issue-term=pathname label=almo7aya.dev theme=dark-blue crossorigin=anonymous async></script></div></div></div><footer id=footer><img id=image src=/images/avatar.jpg alt><div class=name>üìç üáæüá™</div><div class=name>Ali Almohaya</div><div class=link>GitHub: <a target=_blank href=https://github.com/almo7aya>@almo7aya</a></div><div class=link>Twitter: <a target=_blank href=https://twitter.com/@almo7aya_>@almo7aya_</a></div><div class=link>LinkedIn: <a target=_blank href=https://linkedin.com/in/almo7aya>Ali Almohaya</a></div><div class=link><a target=_blank href=mailto:alialmohaya@gmail.com>alialmohaya@gmail.com</a></div><div class=license>Licensed under a <a target=_blank href=https://creativecommons.org/licenses/by/4.0/>CC Attribution 4.0
International
License</a></div></footer></body><link rel=stylesheet href=/lib/font-awesome/css/all.min.css><script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
<script src=/js/code-copy.js></script></html>